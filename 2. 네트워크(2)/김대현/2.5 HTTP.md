## 2.5.1 HTTP/1.0

한 연결 당 하나의 요청을 처리

### RTT 증가

### 해결책

- 이미지 스플리팅
- 코드 압축
- 이미지 Base64 인코딩

---

## 2.5.2 HTTP/1.1

![](attachments/Pasted%20image%2020230210140125.png)

keep-alive 설정을 통해 한 번의 TCP handshake 이후 여러 파일을 송수신할 수 있다.

하지만 여전히 리소스 개수에 비례해서 대기 시간이 길어지는 단점이 있다.

---

### HOL Blocking

Head of line blocking

같은 큐에 있는 패킷이 앞쪽 패킷 때문에 지연되어 발생하는 성능 저하 현상

![](attachments/Pasted%20image%2020230210140348.png)

정확하게 일어나는 원인은?

---

### 무거운 헤더 구조

HTTP/1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어가 있어 무겁다.

---

## 2.5.3 HTTP/2

구글이 만든 SPDY 프로코톨에서 파생됨.

지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있다.

- 멀티플렉싱
- 헤더 압축
- 서버 푸시
- 요청의 우선순위 처리

등을 지원한다.

---

### 멀티플렉싱

여러 개의 스트림을 사용하여 송수신. 특정 패킷이 손실되었다 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 동작함.

![](attachments/Pasted%20image%2020230210140817.png)

HOL Blocking 해결

---

### 헤더 압축

허프만 코딩 압축 알고리즘을 사용해 HPACK 압축 형식을 가진다.

---

### 서버 푸시

클라이언트의 요청 없이 바로 리소스를 보내버리는 것.

html 을 요청했다면 어차피 js, css 파일이 포함되어야 하므로 클라이언트에서 알아서 한꺼번에 다 보내버리는 기술

---

## 2.5.4 HTTPS

HTTP/2는 HTTPS 위에서 동작.

애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청을 뜻한다.

통신 암호화

### SSL/TLS

Secure Socket Layer
Transport Layer Security Protocol

전송 계층에서 보안을 제공하는 프로토콜. 제 3자의 도청과 변조를 막는다.

- 인증 메커니즘
- 키 교환
- 해싱

---

### 보안 세션

보안이 시작되고 끝나는 동안 유지되는 세션을 말하고, SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등을 공유

- 세션: 운영체제가 어떤 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간을 뜻한다. 즉 사용자는 일정 시간 동안 응용 프로그램, 자원 등을 사용할 수 있다.

![](attachments/Pasted%20image%2020230210142830.png)

잘 몰라서 추가로 공부해야 함.

---

1-RTT를 소모하여 인증, 인증 확인하는 작업 이후 데이터 송수신한다. 이때 사이퍼 슈트를 클라에서 서버로 보낸다.

### 사이퍼 슈트

Cyper suites

프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말한다.

---

### AEAD 사이퍼 모드

Authenticated Encryption with Associated Data

데이터 암호화 알고리즘.

AES_128_GCM은 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 GCM이 결합됨.

---

### 인증 메커니즘

CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어진다.

안전한 연결을 시작하는 데에 있어 필요한 '공개키'를 클라이언트에 제공하고 사용자가 접속한 '서버가 신뢰'할 수 있는 서버임을 보장한다.

- 서비스 정보
- 공개키
- 지문
- 디지털 서명

등으로 이루어져 있다.

CA는 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있다.

- Comodo
- GoDaddy
- GlobalSign
- Amazon

등이 있다.

---

CA 인증서를 발급 받으려면 자신의 사이트 정보와 공개키를 CA에 제출해야 한다. 이후 CA는 공개키를 해시한 값이 지문 (finger print)를 사용하는 CA의 비밀키 등을 기반으로 CA 인증서를 발급한다.

---

### 암호화 알고리즘

- ECDHE (Elliptic Curve Diffie-Hellman Ephemeral): 대수곡선 기반의 알고리즘
- DHE (Diffie-Hellman Ephemeral): 모듈식 기반

---

### Diffie Hellman

각자의 비밀키는 혼자만 (절대 네트워크로 통신 금지)
공개키는 공유

공개키와 비밀키를 혼합한 값은 공유

그 값을 각자의 비밀키와 혼합하면 공통의 암호키 생성 (PSK, pre-shared key)

---

TLS 1.3 은 사용자가 이전에 방문한 사이트로 다시 재방문할때 SSL/TLS 보안 세션 통신을 다시 하지 않아도 괜찮다. 0-RTT

---

### SEO

- 캐노니컬 설정
- 메타 설정 ![](attachments/Pasted%20image%2020230210143300.png)

---

### 페이지 속도 개선

구글의 PaegSpeedInsights 로 가서 자신의 서비스에 대한 리포팅을 받을 수 있다.

![](attachments/Pasted%20image%2020230210143409.png)

---

### 사이트맵 관리

사이트맵 제너레이터를 사용한다.

---


### HTTPS 구축 방법

- 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스를 구축
- 서버 앞단의 HTTPS를 제공하는 로드밸런서를 둔다.
- 서버 앞단에 HTTPS를 제공하는 CDN을 둔다. 

---

## 2.5.5 HTTP/3

HTTP/2와 다르게, 3는 QUIC 기반으로 돌아가며, UDP를 주로 사용합니다.

![](attachments/Pasted%20image%2020230210143644.png)

---

### 초기 연결 설정 시 지연 시간 감소

3 way handshaking 을 하지 않고 1-RTT 만에 연결할 수 있다. 클라이언트가 서버에 신호를 주고, 서버도 응답하기만 하면 바로 본 통신을 시작할 수 있다.

![](attachments/Pasted%20image%2020230210143927.png)

이 사진은 무슨 의미일까...?

### 순방향 오류 수정 메커니즘

FEC

Forward Error Correction

전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식. 열악한 네트워크에서도 낮은 패킷 손실률을 자랑한다.

---

### 예상 질문

#### HTTP의 발전을 주욱 설명하고 각각의 단계마다 추가된 장점을 말하시오.

### 