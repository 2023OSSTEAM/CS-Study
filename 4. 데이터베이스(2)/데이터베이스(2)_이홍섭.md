# 4. 데이터베이스(2)

## 목차
### 4.4 데이터베이스의 종류 (선택)
- 4.4.1 관계형 데이터베이스
- 4.4.2 NoSQL 데이터베이스
### 4.5 인덱스
- 4.5.1 인덱스의 필요성
- 4.5.2 B-트리
- 4.5.3 인덱스 만드는 방법
- 4.5.4 인덱스 최적화 기법
### 4.6 조인의 종류 (선택)
- 4.6.1 내부 조인
- 4.6.2 왼쪽 조인
- 4.6.3 오른쪽 조인
- 4.6.4 합집합 조인
### 4.7 조인의 원리
- 4.7.1 중첩 루프 조인
- 4.7.2 정렬 병합 조인
- 4.7.3 해시 조인
---
# 4.4 데이터베이스의 종류
## 1. 관계형 데이터베이스
- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 DB를 가리킨다
- SQL이라는 언어를 써서 조작한다
- 대표적으로 MySQL, PostgreSQL 등이 있다.
## 2. NoSQL 데이터베이스
- Not only SQL 이라는 슬로건에서 생겨난 DB이다
- SQL을 사용하지 않는 데이터베이스를 말한다
- 대표적으로 몽고DB, redis 등이 있다.
# 4.5 인덱스
## 1. 인덱스의 필요성
- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다
    - 예를 들어 책의 마지막 장에 있는 찾아보기를 생각하면 된다
- 책의 본문 안의 특정한 개념이나 단어를 빠르게 찾을 수 있듯이, 인덱스도 DB에서 원하는 데이터를 빠르게 찾을 수 있도록 한다.
## 2. B-트리
<img width="625" alt="image" src="https://user-images.githubusercontent.com/97447334/223320734-95c0cf33-76ef-4110-bae7-6519eb3bd503.png">

MySQL,PostgreSQL등 대부분의 DB 시트템에서 인덳느는 보통 `B-tree` 라고하는 자료구조로 이루어져 있다.<br>
B-tree는 `Root노드`, `Leaf노드`, 그 사이의 `Branch노드`로 나뉜다
- 특성으로는
    - 루트에서 리프 노드까지의 경로의 길이는 모두 같다
    - 루트나 리프가 아닌 노드의 자식 노드의 수는 [n/2, n]개로 한정된다
    - 리프 노드의 값은 [(n-1)/2, n-1]로 한정된다
- B-tree는 Binary search tree와 유사하지만, 한 노드 당 자식 노드가 2개 이상 가능하다.
- key 값을 이용해 찾고자 하는 데이터를 트리 구조를 이용해 찾는 것이다.
- 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리 구조와 트리 깊이의 **대수확장성** 때문에 인덱스가 효율적이다.

>**대수확장성이란?**<br>
트리 깊이가 리프 노두 수에 비해 매우 느리게 성장하는 것을 의미한다.<br> 
기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.

## 3. 인덱스 만드는 방법
인덱스를 생성하는 방법은 DB마다 다르며 이에 따른 인덱싱의 방식에도 약간 차이가 있다
### 1) MySQL
- 클러스터형 인덱스와 세컨더리 인덱스가 있다.
- `클러스터형 인덱스`
- <img width="650" alt="image" src="https://user-images.githubusercontent.com/97447334/223322329-470a4ce9-2981-46ff-84f5-e1413280c435.png"><br>
    - **테이블 전체가 정렬된 인덱스가 되는 방식**의 종류이다
    - 실제 데이터와 무리(cluster)를 지어 인덱싱 되므로 클러스터형 인덱스라 부른다
    - 영어 사전과 비슷하다. 영어 사전은 영어 단어가 사전순으로 정렬되어 있으면서, 영어 단어의 뜻도 함께 존재하기 때문이다
    - 테이블당 하나를 설정할 수 있다.
    - PK 옵션으로 기본키로 만들면 생성할 수 있다.
    - PK로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.
- `세컨더리 인덱스`
- <img width="745" alt="image" src="https://user-images.githubusercontent.com/97447334/223322291-bbd41332-0996-450d-ac90-84b42f8c16de.png">

    - create index…. 명령어를 기반으로 만들면 만들 수 있다
    - 하나의 인덱스만 생성할 것이라면 성능상 클러스터형 > 세컨더리 인덱스
    - 보조 인덱스로 **여러 개의 필드 값**을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스 이다.

### 2) MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 key가 기본키로 설정된다
- 세컨더리 key도 부가적으로 설정해서 기본키와 세컨더리key를 같이 쓰는 복합 인덱스 설정 가능

## 4. 인덱스 최적화 기법

### 1) 인덱스와 비용

- 인덱스의 구조에서 보았듯이 익덱스를 탐색하는데 필요한 일정 비용이 있다
    - 두 번 탐색하도록 강요된다. 인덱스 리스트 → 컬렉션
- 또한 인덱스 삽입과 삭제 연산과 관련해서도 균형을 유지하기 위한 유지보수 비용이 소모된다
- **때문에 뭐리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 비효율적이다.** 이러한 점을 고려하여 인덱스를 설정해야 한다

### 2) 테스팅
- 인덱스 최적화 기법은 서비스 특징에 따라 달라진다
    - 서비스에서 사용하는 객체의 깊이,테이블의 양 등이 다르기 때문에
- **때문에 항상 테스팅하는 것이 중요하다!**
    - MySQL에서는 EXPLAIN같은 함수를 통해 테스팅을 수행할 수 있다

### 3) 복합 인덱스의 순서

>대개 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.<br>
같음, 정렬, 다중 값 , 카디널리티 순으로 생성해야 한다

1. 값을 비교하는 `==` 이나 `equal`이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다
2. `정렬`에 사용되는 필드를 인덱스로 설정
3. 쿼리 자체가 부등호< , >와 같은 연산이 있어 `다중 값`을 출력 해야한다면 인덱스로 설정함
4. `카디널리티`(유니크한 값의 정도)가 높은 순서를 기반으로 인덱스를 생성한다
    1. ex) age와 email중 카디널리티는 email이 더 높으므로 email 필드에 대한 인덱스를 먼저 생성해야 한다
# 4.6 조인의 종류
>**조인**이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말한다
<br>보통 NoSQL보단, 관계형 데이터베이스에서 많이 사용된다 (성능상)

## 1. 내부 조인
```sql
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```
- 두 테이블 간에 **교집합**을 나타낸다
## 2. 왼쪽 조인
```sql
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```
- 테이블B의 일치하는 부분의 레코드와 함께 **테이블A를 기준**으로 완전한 레코드 집합을 생성
- 만약 B테이블에 일치하는 항목이 없다면 해당 값은 null값이 된다
## 3. 합집합 조인
```sql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```
- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 **모든 레코드 집합을 생성**한다
- 이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력된다

# 4.7 조인의 원리

>앞서 나온 조인들은 조인의 원리를 기반으로 조인 작업이 이루어진다<br>
각 조인의 방법바다 장단점이 있고, 조인의 성격과 조인의 원리의 디스크 I/O 복잡도에 따라 성능이 상이하다

## 1. 중첩 루프 조인 (NLJ)

- **2중 for문과 같은 원리로 조인하는 방법**
    - ex) A1,A2 테이블을 조인한다면, 첫 번째 테이블에서 행을 한 번에 하나씩 읽고 그 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결과값 반환
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서 사용X
- 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나누어서 블록 하나씩 조인하는 `블록 중첩 루프 조인` 방식도 있다

## 2. 정렬 병합 조인

- 각각의 테이블을 **조인할 필드 기준으로 정렬**하고, 정렬이 끝난 이후에 조인 작업을 수행하는 조인
- 조인할 때 적절한 인덱스가 없고 대용량의 테이블들을 조인하고, 조인 조건으로 <,>등 범위 비교 연산자가 있을 때 쓴다

## 3. 해시 조인

- **해시 테이블을 기반**으로 조인하는 방법
- 해시 조인은 우선 두 테이블 중 크기가 작은 테이블을 기준으로 조인에서 사용되는 필드의 데이터를 해싱된 키가 매핑된다
- 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면, 보통 중첩 루프 조인(NLJ)보다 더 효율적이다
- 동등(==)조건에서만 사용할 수 있다
