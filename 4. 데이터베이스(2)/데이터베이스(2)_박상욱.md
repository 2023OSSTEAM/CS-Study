
# 인덱스의 필요성

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.


# B-트리

인덱스는 보통 B-트리라는 자료 구조로 이루어져 있다.
이는 **루트 노트**, **리프 노트** 그리고 루트 노드와 리프 노드 사이에 있는 브랜치 노드로 나뉜다.

B-트리는 탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree 의 일종이다.

자식 node의 개수가 2개 이상이며, node 내의 key가 1개 이상일 수도 있다.
node의 자식 수 중 최댓값이 K(만약 3)라고 하면, 해당 B-Tree를 K(3)차 B-트리이다.

### B-트리의 조건

- 노드가 자식을 K개 가졌다면, key는 K-1개를 가진다.
- 노드의 key는 반드시 오름차순으로 정렬된 상태여야 한다.
- 루트 노드는 항상 2개 이상의 자식 노드를 가진다. (루트 노드가 리프 노드인 경우는 제외)
- K차 트리일 떄, 루트 노드와 리프 노드를 제외하고 각 노드의 최소 자식 노드 수는 [M/2]
  각 노드의 최소 key 수는 [m/2]-1 이 된다.


### B-트리 검색
![b-tree](https://user-images.githubusercontent.com/96435200/224529864-8eb5f7c4-9a46-42af-a59e-cdb2bf32a365.png)


### DB에서 B-Tree를 인덱스로 사용하는 이유

일반적인 Tree의 경우 탐색하는데 평균적인 시간 복잡도로 O(logN)을 갖지만,
트리가 편향된 경우 최악의 시간복잡도로 O(N)을 가지게 된다.

B-Tree는 편향적이지 않고 밸런스를 유지하는 트리이기에 자식들의 밸런스를 잘 유지하면
최악의 경우에도 O(logN)의 시간을 가지게 된다.

![b-tree 2](https://user-images.githubusercontent.com/96435200/224529869-0b6b95d2-9fd8-40ce-b68c-85d9c8472ef3.png)



DB는 기본적으로 secondary storage(SSD or HDD)에 저장된다.

평균적인 경우에 B-트리는 **네 개의 level만으로도 수백 만, 수 천만 개의 데이터를 저장할 수 있다.**
**루트 노드에서 가장 멀리 있는 데이터도 3번의 이동만으로 접근할 수 있다.**

따라서 데이터를 찾기위해 secondary storage에 접근을 적게한다.
또한 block 단위의 저장 공간을 알차게 사용할 수 있다.


---

# 인덱스 만드는 방법

인덱스는 크게 Cluster index 와 Non-Clustered index가 있다.

### Cluster index

- 각 테이블 / 뷰가 하나의 Cluster index만 가질 수 있다.
- Cluster index는 작업에 필요한 메모리가 적기 때문에 더 빠르다. (검색에 빠르다.)
  이는 Cluster index의 리프 노드가 행 식별자(pointer의 개념)가 아닌 실제 데이터를 저장하기 때문이다.
- 어느 열에 Cluster index를 생성하느냐에 따라서 시스템의 성능이 달라질 수 있다.
- Cluster index가 지정되어 있지 않는 테이블에 이미 대용량의 데이터가 입력된 상태라면
  Cluster index를 생성하는 것은 시스템에 큰 부하를 가져다 줄 수 있다.
- 테이블 생성 시 Primary Key를 사용하면 Cluster index가 생성된다.

![Cluster Index](https://user-images.githubusercontent.com/96435200/224529872-c0d502f7-d7fc-40a4-9618-5dfa33390125.png)



### Non-Clustered index

- Non-Clustered index는 논리적 인덱스이며 인덱스가 작성된 열에 따라 테이블 / 뷰의 데이터를
  정렬하지 않는다.
- 입력 / 수정/ 삭제 등에 Cluster index 보다 쿼리의 성능을 향상 시킬 수 있다.
- Non-Clustered index는 하나가 아니라 여러 개 생성할 수 있지만 남용할 경우 성능 저하를 가져올 수 있다.
- UNIQUE 제약 조건을 생성하면 기본적으로 Non-Clustered index 가 생성된다.

![Non_Clustered index](https://user-images.githubusercontent.com/96435200/224529877-7544061d-1e0f-4d6f-ac75-cd7064bd9386.png)



---

## 인덱스 최적화 기법

### 인덱스는 비용이다.

먼저 인덱스는 두 번 탐색하도록 강요한다.
인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문이며, 관련 읽기 비용(처리 소요시간, 자원량 등)도 들게 된다.
또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다.
그렇게 때문에 쿼리에 있는 필드에 무작정 다 인덱스를 설정하는 것이 답은 아니다.
한, 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.

### 항상 테스팅하라.

expain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화하자.

### 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.

보통 여러 필드를 기반으로 조회를 할 떄 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는
순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.

같음, 정렬, 다중 값, 다키널리티 순으로 생성해야 한다.

- 어떠한 값곽 같음을 비교하는 == 이나 equal 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
- 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다.
- 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >, < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면
  나중에 인덱스를 설정한다.
- 카디널리티(고유성)을 바탕으로 카디널리티가 높은 (중복되는게 적은) 순서를 기반으로 인덱스를 생성해야 한다.


---
---
---


조인의 원리인 중첩 루프 조인, 정렬 병합 조인, 해시 조인에 대해 알아보자

https://sql-joins.leopard.in.ua/

## 중첩 루프 조인

중첩 루프 조인은 (NJL, Nested Loop Join)은 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법이다.
랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않는다.

2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 행을 결합하여 원하는 결과를 조합하는 조인방식으로, 선정된 한 테이블로부터 where 절에 정의된 검색 조건을 만족하는 데이터들을 걸러낸 후,
이 값을 가지고 조인 대상 테이블을 반복적으로 검색하면서 조인 조건에 만족하는 최종 결과값을 얻어낸다.

![Nested Loops Join](https://user-images.githubusercontent.com/96435200/224529906-6f23a102-3d8a-4a91-b157-4fdb617fd350.png)

1. 선행 테이블에서 조건을 만족하는 첫 번째 행을 찾는다. -> 이떄 선행 테이블에 주어진 조건을 만족하지 않는 경우 해당 데이터는 필터링 된다.
2. 선행 테이블의 조인 키를 가지고 후행 테이블에 조인 키가 존재하는지 찾으러 간다. -> 조인 시도
3. 후행 테이블의 인덱스에서 선행 테이블의 조인 키가 존재하는지 확인 -> 선행 테이블의 조인 키 값이 후행 테이블에 존재하지 않으면 데이터는 필터링 됨 (조인 작업을 진행할 필요가 없음)
4. 모두 만족한 해당 행을 추출 버퍼에 넣음
5. 반복


### 중첩 루프 조인 장단점

- 인덱스에 의한 랜덤 엑세스에 기반하고 있기 때문에 대량의 데이터 처리 시 적합하지 않다.
- 선정된 테이블은 데이터가 적거나 where 절 조건으로 행의 숫자를 줄일 수 있는 테이블이어야 한다.
- 비선정된 테이블은 조인을 위한 적절한 인덱스가 생성되어 있어야 한다.
- 선행 테이블의 결과를 통해 후행 테이블을 액세스 할 떄 랜덤 I/O이 발생한다.





## 정렬 병합 조인

정렬 병합 조인(Sort Merge Join)이란 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인이다.

조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 < , > 등 범위 연산자가 있을 때 사용한다.

![Sort Merge Join](https://user-images.githubusercontent.com/96435200/224529910-96bb8900-4bd0-44fe-8f1f-e1b94ec10cc5.png)

1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾는다.
2. 해당 행들에 대해서, 선행 테이블의 조인 키(컬럼)을 기준으로 데이터를 정렬
3. 후행 테이블에서 주어진 조건을 만족하는 행을 찾는다.
4. 해당 행들에 대해서, 후행 테이블의 조인 키(컬럼)을 기준으로 데이터를 정렬
5. JOIN을 수행
6. 조인에 성공하면 추출버퍼에 넣는다.




## 해시 조인

해시 조인은 해시 테이블을 기반으로 조인하는 방버이다. 두 개의 테이블을 조인한다고 했을 때
하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적이다.
하지만, 동등 (=) 조인에서만 사용가능하고, 데이터가 크다면 디스크를 사용하는 비용이 발생한다.

해쉬 함수를 적용한 실제 값은 어떤 값으로 Hashing 될 지 예측할 수 없다.
하지만 해쉬 함수가 적용될 때 동일한 값은 항상 같은 값으로 Hashing 됨이 보장된다.
따라서 해쉬 조인은 동등 조인 (=) 에서만 사용할 수 있는 것이다.


### 빌드 단계

해쉬 조인은 조인 작업을 수행하기 위해 '해쉬 테이블'을 메모리에 생성한다.
해쉬 테이블의 크기가 메모리에 적재할 수 있는 크기보다 커지면 디스크에 해쉬 테이블을 지정하기에
해쉬 조인을 할 때는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다.


### 프로브 단계

후행 테이블은 만들어진 해쉬 테이블에 대해 해쉬 값 존재여부를 검사한다.
이를 Prove Input 이라고 한다.

![Hash Join](https://user-images.githubusercontent.com/96435200/224529917-c5457375-6c10-4bcb-a3ca-3aea28dcb144.png)


1. 선행 테이블에 주어진 조건을 만족하는 행을 찾는다.
2. 해당 행들에 대해서, 선행 테이블의 조인 키(컬럼)를 기준으로 Hash 함수를 적용하여 해쉬 테이블을 생성한다
3. 후행 테이블에서 주어진 조건에 맞는 행을 찾는다.
4. 해당 행들에 대해서, 후행 테이블에 Hash 함수를 적용하여 선행 테이블의 해쉬 테이블에 맞는 버킷을 찾는다.
5. JOIN 수행이 성공하면 추출 버퍼에 넣는다.
6. 후행 테이블의 조건을 만족하는 모든 행에 대해서 3~5번을 반복한다.



